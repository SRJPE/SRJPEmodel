---
title: "Adult Modeling"
output: rmarkdown::html_vignette
#output: rmarkdown::word_document
author:
  - Liz Stebbins, Ashley Vizek, Erin Cain, Josh Korman
vignette: >
  %\VignetteIndexEntry{Adult Modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)

```

```{r setup, include = FALSE}
library(ggplot2)
library(tidyverse)
library(tidybayes)
```

```{r, echo = FALSE}
# source data prep ------------------------------------------
# source(here::here("data-raw", "adult_model", "adult_model_data_prep.R"))
# source(here::here("data-raw", "adult_model", "predicted_spawners_STAN.R"))
# 
# rm(list=ls())

# best model - to get coefficients
load(here::here("data-raw", "adult_model", "best_adult_models.Rdata"))

# now read in csvs generated by sourcing scripts
survival_model_data_raw <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "survival_model_data_raw.csv"))
survival_model_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "survival_model_data.csv"))
battle_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "battle_data.csv"))
clear_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "clear_data.csv"))
deer_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "deer_data.csv"))
mill_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "mill_data.csv"))
yuba_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "yuba_data.csv"))
butte_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "butte_data.csv"))
feather_data <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                               "feather_data.csv"))
model_fit_summaries <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                    "model_fit_summaries.csv")) |> 
  rename(`2.5` = "X2.5.", `25` = "X25.", `50` = "X50.", `75` = "X75.", `97.5` = "X97.5.") |> 
  mutate(lcl = round(`2.5`, 3), ucl = round(`97.5`, 3)) |> unite(CIs, c(lcl, ucl), sep = ", ")
diagnostic_pars <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                       "model_fit_diagnostic_pars.csv"))
adult_data_for_spawn_recruit <- read.csv(here::here("data-raw", "adult_model", "adult_model_data",
                                    "adult_data_for_spawn_recruit.csv"))
```


## Spawning Adult Abundance in the Spring Run JPE

The Spring run JPE can use estimates of number of spring-run Chinook salmon spawning adults for each tributary with associated uncertainty. These estimates can be passed into the spawn-recruit submodel which connects spawning adults within each tributary to juvenile production for the system.

Spawner abundance can be quantified through redd surveys, swim counts of holding fish, carcass surveys, or through analyzing video of upstream passage. For some streams, both upstream passage data and a survey of the spawning area (redd, holding, or carcass) were available and the relationship between these two data sources could be modeled. This was the preferable approach because it allows for a forecast of spawner abundance from passage estimates. Data availability and reliability varied by stream and ultimately not all streams could support a modeled relationship, so three methods for producing adult abundance were used:

1. Modeling spawner abundance as a function of upstream passage and pre-spawn survival
2. Estimating spawner abundance using a Cormack Jolly-Seber model applied to carcass surveys
3. Estimating adult upstream passage counts with modeled uncertainty via spline

Data completeness, quality, and availability varied across streams (outlined in the Adult Data Report) and were used to decide to which streams Method 1 could be applied. Battle Creek, Clear Creek, Mill Creek, and Deer Creek could all be modeled using Method 1 because they had robust spawner count data (redd surveys for Battle, Clear, and Mill; holding surveys for Deer) and upstream passage data. Butte Creek, Feather River, and Yuba River data were not sufficient for modeling with Method 1.

Butte Creek and Feather River both had high quality carcass surveys and spawner abundances were estimated using Method 2 (CJS). Yuba River had upstream passage data and performs carcass surveys but only had CJS estimates for four years (2014, 2015, 2019, and 2020). Because of these limitations, Yuba River spawner abundances were estimated using Method 3.

Methods 2 and 3 were conducted by the stream monitoring programs themselves and results of the CJS model and upstream passage estimates were provided by staff directly for Butte Creek, Feather River, and Yuba River. The specific methods applied in these streams are available ([Butte](https://www.calfish.org/ProgramsData/ConservationandManagement/CentralValleyMonitoring/SacramentoValleyTributaryMonitoring/ButteCreek.aspx) and [Feather](https://deltacouncil.ca.gov/pdf/science-program/fact-sheets/2020-10-06-monitoring-chinook-salmon.pdf): unpublished reports; Yuba: Poxon, B., P. Bratovich. 2020. Lower Yuba River Vaki Riverwatcher Chinook Salmon Passage and Run Differentiation Analyses. HDR). 


### Method 1: Adult Upstream Passage and Prespawn Mortality

#### Data Sources 

Battle Creek, Clear Creek, Deer Creek, and Mill Creek data were combined into one dataset where `spawner_count` represented the survey associated with spawning adults (either `redd_count` or `holding_count`) and `upstream_count` represented the estimates of adults passing through the video stations. Stream monitoring programs provided estimates of upstream passage directly.

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |> 
  mutate(spawner_count = ifelse(stream == "deer creek", holding_count, redd_count)) |> 
  ggplot(aes(x = year, y = spawner_count, color = "Spawner count (redd/holding)")) + 
  geom_line() +
  geom_line(aes(x = year, y = upstream_count, color = "Upstream passage")) +
  facet_wrap(~stream, scales = "free_y") + 
  xlab("Year") + ylab("Abundance") + 
  ggtitle("Spawner survey data and upstream passage by stream") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1),
        legend.position = "bottom") +
  scale_color_discrete(name = "Adult data type")
```

Generally, `upstream_count` exceeded `spawner_count`, though the plot assumes no error in these values. There were several years for each stream (except Battle) where `spawner_count` exceeded `upstream_count`. While these data were not biologically feasible, we did not remove them from the dataset and instead accounted for this in the model, as described below.

#### Calculating Prespawn Survival

Prespawn survival, or the proportion of adults that survived from upstream passage to spawn, was calculated as `upstream_count / spawner_count`. When we were using redd counts as `spawner_count`, our model assumed a 50/50 sex ratio and modified that equation to be `upstream_count / (spawner_count * 0.5)`,. Generally, one redd per female is a reasonable assumption although our model left the possibility open for more than one redd per female [(source)](https://www.researchgate.net/publication/233231658_The_Number_of_Redds_Constructed_per_Female_Spring_Chinook_Salmon_in_the_Wenatchee_River_Basin).

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |> 
  ggplot(aes(x = year, y = prespawn_survival, color = stream)) +
  geom_line() +
  xlab("Year") + ylab("Prespawn Survival") + 
  ggtitle("Prespawn Survival by Stream") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1),
        legend.position = "bottom")
```

### Environmental Covariates 

To better understand the relationship between `upstream_count` and `spawner_count` (i.e. `prespawn survival`), we explored  the relationship with four environmental covariates that we hypothesized could influence prespawn mortalitiy rates:

* flow
* temperature
* upstream passage timing
* water year type (wet or dry)

Temperature, passage timing, and flow could be summarized in several different ways, and so we considered different methods. We investigated potential collinearity between these covariates.

#### Flow 

While mean flow is useful for comparing across streams, we decided maximum flow more effectively captured the high flow events that would support migration speed and passage to upstream holding areas. Additionally, upon inspection of the data source across multiple years average maximum flow over the migratory and holding months (March-May and May-August, respectively) was more representative of the fluctuations in flow over the entire year. We decided to use maximum flow based on those criteria.


#### Temperature

Several approaches were considered for summarizing temperature: 

1. Proportion of days where the temperature surpassed a threshold of 20 degrees Celsius [(source)](https://www.noaa.gov/sites/default/files/legacy/document/2020/Oct/07354626766.pdf) 
2. Growing degree days (GDD) with a base temperature of 0 degrees Celsius [(source)](https://www.researchgate.net/publication/279930331_Fish_growth_and_degree-days_I_Selecting_a_base_temperature_for_a_within-population_study and input from MAT team)  
3. Degree Day 20 (DD20), where cumulative degree days are calculated against a threshold of 20 degrees Celsius [(source)](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0204274) 

For each metric approach, we calculated the metric for migration months (March - May) in the Sacramento River and holding months (May - August) in each tributary. We tested both the individual effects of migratory and holding temperatures as well as a cumulative metric (summed migratory and holding temperatures).

We visually inspected regressions of prespawn survival against each of the three temperature metrics. Metrics 1 and 2 did not show a consistent relationship across streams, and in particular metric 1 was not considered to sufficiently capture the relationship between temperature, time exposed to high temperatures, and the cumulative effect of exposure to high temperatures on stress. We decided on metric 3 and used the summed approach (DD20) across migration and holding months.

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |>  
  filter(stream != "mill creek") |> 
  ggplot(aes(x = total_prop_days_exceed_threshold, y = prespawn_survival, color = stream)) + 
  geom_smooth(method = "lm") + 
  ggtitle("Proportion of days exceeding threshold as predictor variable") +
  ylab("Prespawn Survival") + xlab("Proportion of days exceeding threshold") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1),
        legend.position = "bottom")
```

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |> 
  filter(stream != "mill creek") |> 
  ggplot(aes(x = gdd_total, y = prespawn_survival, color = stream)) + 
  geom_smooth(method = "lm") + 
  ggtitle("Degree days (20) as predictor variable") + 
  ylab("Prespawn survival") + xlab("DD20") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1),
        legend.position = "bottom")
```



#### Passage Timing 

We summed passage at weekly intervals for streams where such data was available. 

We considered the following metrics for passage timing: 

1. Minimum passage timing 
2. Median passage timing 
3. Mean passage timing 

We used upstream passage estimates instead of raw counts to calculate prespawn survival, but used raw upstream passage counts to calculate passage timing because passage estimates were summarized by year. Because some years were not available for raw counts in Clear Creek, some years have prespawn survival and no passage timing (2000-2012).

Minimum passage timing could theoretically capture not only passage timing but also how long fish were exposed to higher temperatures (i.e. the earlier the first passage timing, the less time exposed to high temperatures later in the year), inspection of plots of passage counts by year and stream showed that the bulk of the fish were not being captured by the minimum passage metric.

Median and mean passage timing were very similar across years, rarely differing by more than 2 weeks:

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |> 
  mutate(diff = median_passage_timing - mean_passage_timing) |> 
  ggplot(aes(x = year, y = diff)) + 
  geom_line() +
  geom_hline(aes(yintercept = 0), color = "red", linetype = "dashed") +
  facet_wrap(~stream) +
  xlab("Year") + ylab("Difference between median and mean passage timing") + 
  theme_minimal()
```

We decided upon median passage timing over mean passage timing as it performed better in automated model selection.

#### Water Year Type 

To account for the influence of large scale interannual climate variability, we investigated water year type as a covariate as described by the [California Department of Water Resources](https://cdec.water.ca.gov/reportapp/javareports?name=WSIHIST) and available in the [waterYearType package in R](https://cloud.r-project.org/web/packages/waterYearType/index.html). Because for some streams we had very few years of complete data for all variables (i.e. for Mill Creek, only seven years were available), we simplified all potential categories of water year type into either dry (Dry, Below Normal, Critical) or wet (Wet, Above Normal) to reduce the number of parameters that needed to be estimated.

To account for year effects, we used the `waterYearType` package to pull water year assignments as a categorical covariate. Because for some streams we had very few data points (i.e. for Mill Creek, only seven years were considered dependable), we simplified all potential categories of water year type into either dry (`Dry`, `Below Normal`, `Critical`) or wet (`Wet`, `Above Normal`).

```{r}
survival_model_data_raw |> 
  filter(!stream %in% c("yuba river", "feather river", "butte creek")) |> 
  ggplot(aes(x = year, y = prespawn_survival, 
             color = water_year_type)) +
  geom_point() +
  facet_wrap(~stream, scales = "free") + 
  xlab("Year") + ylab("Prespawn survival")  + 
  ggtitle("Prespawn survival by water year type") +
  theme_minimal() +
  scale_color_discrete(name = "Water year type", 
                       labels = c("Dry", "Wet")) 
```

#### Statistical Importance of Covariates

We used the following approach for identifying key environmental covariates for each individual stream:

1. Look for correlation among predictor variables - visual inspection of a pairs plot, ruling out correlations above a threshold of `0.65`, and using variation inflation factor (VIF) analysis to eliminate highly correlated variables. 
2. Use information in step 1 to remove any confounding variables. 
3. Use the package `glmulti` to select the best combination of remaining variables in a linear regression based on AIC.

We only looked for univariate models (i.e. did not consider interactions and focused on identifying one predictor variable) in the linear regressions due to limited data: several streams had a sample size of less than `10` which was not enough statistical power to fit interaction terms. 

The selected coefficients for each stream were: 

* Battle: `r c(names(coef(best_adult_models$best_battle_lm))[2], round(coef(best_adult_models$best_battle_lm)[2], 3))`
* Clear: `r c(names(coef(best_adult_models$best_clear_lm))[2], round(coef(best_adult_models$best_clear_lm)[2], 3))` 
* Mill: `r c(names(coef(best_adult_models$best_mill_lm))[2], round(coef(best_adult_models$best_mill_lm)[2], 3))` 
* Deer: `r c(names(coef(best_adult_models$best_deer_lm))[2], round(coef(best_adult_models$best_deer_lm)[2], 3))`


### Predicted Redd Bayesian model

Once the environmental variables with the most significant predictive power were selected for each stream, they were used to develop a single stream model motivated by [Dauphin et al. (2010)](https://www.sciencedirect.com/science/article/abs/pii/S0165783610001530?via%3Dihub), which models a redd:passage relationship. Once this model was built in a Bayesian framework, the model was run for each stream with each environmental covariate to confirm our previous selections. Criteria for covariate selection under the redd:passage model and results are detailed later.

The model takes in observed upstream passage and observed spawner count, as well as an environmental covariate. All environmental covariates except water year type (a binary variable of 0/1 for dry/wet) were standardized and centered so that scale would not impact the results of the model. 

Our model calculates survival on a logit scale. The conversion rate (of adults passage to spawning adults) in a year (`conversion_rate(y)`) is a function of the selected environmental covariate `environmental(y)`, the parameter `b1_survival`, and log-scale redds-per-spawner (`rps(y)`) (Equation 2). `mean_rps` and `sigma_rps` are the hyper parameters determining the distribution of`rps` across years. `rps(y)` is estimated on a log scale to restrict to positive values but allow for values over 1 (Equations 1 and 2). The model then predicts spawner count in a year (`predspawners(y)`) as a function of `observed_passage(y)` and `conversion_rate(y)` (Equation 4). The likelihood assumes the error between `predicted_spawners` and `observed_spawners` is poisson-distributed and that the distribution of `rps` is lognormal as determined by parameters `mean_rps` and `sigma_rps`. The key output of the model is `predspawners(y)` for each year and the estimated effect of the environmental covariate, captured in the parameter `b1_survival`. 

(1) $\log(rps_{y}) \sim {\sf Normal}(\mu_{rps}, \sigma_{rps})$
(2) $conversionrate_{y} = exp(\log(rps_{y}) + \beta_{1}survival * environmental_{y})$
(3) $rps_{y} = \exp(\log(rps_{y}))$
(4) $predspawners_{y} = observedpassage_{y} * conversionrate_{y}$
(5) $observedspawners_{y} \sim {\sf Poisson} (predspawners_{y})$


The model was coded in `rstan`, a language used for implementing models in a Bayesian framework. The model results were assessed using the following diagnostics:

* Proportion of variance in predicted spawners explained by fixed effect `$\beta_{1}survival$`
* Magnitude of the mean of the fixed effect
* Uncertainty in the fixed effect estimate

### Further exploration of covariate

The above criteria were also used to support our choice of environmental covariate for each stream. Each dataset for a stream was truncated to include the same years where all covariates were available. Then, the Bayesian model was fit and criteria examined. A null model where the environmental covariate was set to 0 for each year was considered.
Ultimately, we settled upon the following environmental covariates for each stream (instances where the Bayesian-selected covariate and the linear regression-selected variate differ are noted):

* Battle Creek
* Clear Creek
* Deer Creek
* Mill Creek

```{r, echo = FALSE}
# prep more data for plots
full_data_for_input <- survival_model_data_raw |>
  mutate(wy_type_std = ifelse(water_year_type == "dry", 0, 1),
         wy_type_std = as.vector(scale(wy_type_std)), # TODO double check this. was producing negative b1_surv estimates for wet year types
         max_flow_std = as.vector(scale(max_flow)),
         gdd_std = as.vector(scale(gdd_total)),
         min_passage_timing_std = as.vector(scale(min_passage_timing))) |>
  select(year, stream, upstream_count, redd_count, holding_count,
         wy_type_std, max_flow_std, gdd_std, min_passage_timing_std)

diagnostics <- model_fit_summaries |>
  filter(par_names != "b1_survival") |>
  select(par_names, mean, sd, stream, `2.5`, `97.5`)

obsv_data <- full_data_for_input |>
  mutate(obsv_spawner_count = ifelse(stream == "deer creek", holding_count, redd_count)) |>
  select(year, stream, obsv_spawner_count)

years_to_join <- c(full_data_for_input |> filter(stream == "battle creek") |> drop_na(wy_type_std) |> pull(year),
                   full_data_for_input |> filter(stream == "clear creek") |> drop_na(max_flow_std) |> pull(year),
                   full_data_for_input |> filter(stream == "deer creek") |> drop_na(wy_type_std) |> pull(year),
                   full_data_for_input |> filter(stream == "mill creek") |> drop_na(gdd_std) |> pull(year))

diagnostics_with_year <- diagnostics |>
  arrange(stream) |>
  mutate(year = years_to_join) |>
  select(-par_names) |>
  rename(pred_spawner_count = mean) |>
  left_join(obsv_data, by = c("year", "stream"))
```

#### Results: Battle

The environmental covariate for Battle creek was `water_year_type` and the estimated effect of the environmental covariate in the STAN model (`b1_survival`) was `r model_fit_summaries |> filter(stream == "battle creek", par_names == "b1_survival") |> mutate(mean = round(mean, 3)) |> pull(mean, 3)` with a 95% confidence interval of `r model_fit_summaries |> filter(stream == "battle creek", par_names == "b1_survival") |> pull(CIs)`.

```{r}
diagnostics_with_year |> 
  filter(stream == "battle creek") |> 
  ggplot(aes(x = year, y = obsv_spawner_count)) + 
  geom_point() +
  geom_line(aes(x = year, y = pred_spawner_count)) + 
  geom_ribbon(aes(ymax = `97.5`, ymin = `2.5`), alpha = 0.2) +
  xlab("Year") + ylab("Spawner count") + theme_minimal() + 
  ggtitle("Battle Creek observed vs. predicted spawner count with uncertainty")
```

#### Results: Clear

The environmental covariate for Clear creek was `max_flow` and the estimated effect of the environmental covariate in the STAN model (`b1_survival`) was `r model_fit_summaries |> filter(stream == "clear creek", par_names == "b1_survival") |> mutate(mean = round(mean, 3)) |> pull(round(mean), 3)` with a 95% confidence interval of `r model_fit_summaries |> filter(stream == "clear creek", par_names == "b1_survival") |> pull(CIs)`.

```{r}

diagnostics_with_year |> 
  filter(stream == "clear creek") |>  
  ggplot(aes(x = year, y = obsv_spawner_count)) + 
  geom_point() +
  geom_line(aes(x = year, y = pred_spawner_count)) + 
  geom_ribbon(aes(ymax = `97.5`, ymin = `2.5`), alpha = 0.2) +
  xlab("Year") + ylab("Spawner count") + theme_minimal() + 
  ggtitle("Clear Creek observed vs. predicted spawner count with uncertainty")
```


#### Results: Mill

The environmental covariate for Mill creek was `gdd_total` and the estimated effect of the environmental covariate in the STAN model (`b1_survival`) was `r model_fit_summaries |> filter(stream == "mill creek", par_names == "b1_survival") |> mutate(mean = round(mean, 3)) |> pull(round(mean), 3)` with a 95% confidence interval of `r model_fit_summaries |> filter(stream == "mill creek", par_names == "b1_survival") |> pull(CIs)`.

```{r}
diagnostics_with_year |> 
  filter(stream == "mill creek") |>  
  ggplot(aes(x = year, y = obsv_spawner_count)) + 
  geom_point() +
  geom_line(aes(x = year, y = pred_spawner_count)) + 
  geom_ribbon(aes(ymax = `97.5`, ymin = `2.5`), alpha = 0.2) +
  xlab("Year") + ylab("Spawner count") + theme_minimal() + 
  ggtitle("Mill Creek observed vs. predicted spawner count with uncertainty")
```

#### Results: Deer

The environmental covariate for Deer creek was `water_year_type` and the estimated effect of the environmental covariate in the STAN model (`b1_survival`) was `r model_fit_summaries |> filter(stream == "deer creek", par_names == "b1_survival") |> mutate(mean = round(mean, 3)) |> pull(round(mean), 3)` with a 95% confidence interval of `r model_fit_summaries |> filter(stream == "deer creek", par_names == "b1_survival") |> pull(CIs)`. 

```{r}
diagnostics_with_year |> 
  filter(stream == "deer creek") |> 
  ggplot(aes(x = year, y = obsv_spawner_count)) + 
  geom_point() +
  geom_line(aes(x = year, y = pred_spawner_count)) + 
  geom_ribbon(aes(ymax = `97.5`, ymin = `2.5`), alpha = 0.2) +
  xlab("Year") + ylab("Spawner count") + theme_minimal() + 
  ggtitle("Deer Creek observed vs. predicted spawner count with uncertainty")
```


### Method 2: Carcass data

#### Butte Creek

Butte Creek recommended using adult spawner abundance as estimated by their Cormack Jolly-Seber (CJS) model. These data were acquired directly from stream teams and are available for use.

```{r}
butte_data |>
  ggplot(aes(x = year, y = spawner_estimate)) +
  geom_line() +
  xlab("Year") + ylab("Spawner estimate") +
  ggtitle("Butte creek spawner estimates (CJS)") +
  theme_minimal()
```

#### Feather River

Feather River provided adult spawner abundance as estimated by CJS.
```{r}
feather_data |> 
  ggplot(aes(x = year, y = spawner_estimate)) +
  geom_line() +
  xlab("Year") + ylab("Spawner estimate") +
  ggtitle("Feather River spawner estimates (CJS)") +
  theme_minimal()
```

### Method 3: Upstream Passage Data

#### Yuba River

Yuba River provided upstream passage estimates. This method assumes that `upstream_count` is a proxy for `spawner_count`, and we believe this is a reasonable assumption because anecdotally prespawn mortality is minimal on the Yuba. 

```{r}
yuba_data |>
  ggplot(aes(x = year, y = passage_estimate)) +
  geom_line() +
  xlab("Year") + ylab("Spawner estimate") +
  ggtitle("Yuba river spawner estimates (Upstream passage)") +
  theme_minimal()
```


## All spawner counts

After modeling, the stock-recruit model will be fed a table of spawner counts by stream and year. These are either `modeled_spawners` for Battle, Clear, Mill, and Deer Creeks; `upstream_passage_estimate` for Yuba River; or `carcass_cjs_estimate` for Butte Creek and Feather River. 

```{r}
adult_data_for_spawn_recruit |> 
  ggplot(aes(x = year, y = spawner_count, color = data_type)) + 
  geom_line() +
  xlab("Year") + ylab("Spawner count") +
  ggtitle("Spawner counts by method") +
  scale_color_discrete(name = "Spawner count method", 
                       labels = c("CJS estimates", "Modeled spawners", "Passage estimates")) +
  theme_minimal() +
  facet_wrap(~stream, scales = "free_y") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1),
        legend.position = "bottom")
  
```

## Appendix: diagnostics for STAN model

The STAN model is a mixed-effects model and as such is expected to produce predicted spawner counts that closely match observed spawner counts, with either the fixed effect or random effects absorbing much of the error. To assess the suitability of the model’s fixed effect (which can be forecasted using environmental covariate data), we looked at the predicted vs. spawner counts for each stream and the R squared value of that relationship, and we plotted the survival rate (which incorporates the fixed effect) and log redds-per-spawner parameter estimate (which are the random effects) for each year and stream to assess their magnitude.

### Predicted vs. observed spawner counts

The predicted spawner counts very closely matched the observed spawner counts. The R squared of a linear regression of predicted vs. observed spawner counts was `r round(summary(lm(pred_spawner_count ~ obsv_spawner_count, data = diagnostics_with_year))$r.squared, 3)`. 

```{r}
# plot
diagnostics_with_year |> ggplot(aes(x = obsv_spawner_count, y = pred_spawner_count)) +
  geom_point() + geom_smooth(method = "lm") + facet_wrap(~stream, scales = "free") +
  theme_minimal() + xlab("Observed Spawner Count") + ylab("Predicted Spawner Count")
```

### Random vs. fixed effects

For Battle Creek, the magnitude of the random effects were much greater than those of the fixed effect parameters. 

```{r}
diagnostic_pars |>
  filter(str_detect(par_names, "log_redds_per_spawner") |
         str_detect(par_names, "survival_rate")) |>
  mutate(par_name = ifelse(str_detect(par_names, "log_redds_per_spawner"), "log_rps", "survival")) |>
  arrange(par_name) |>
  mutate(year = rep(years_to_join, 2)) |>
  ggplot(aes(x = year, y = mean, color = par_name)) +
  geom_point() +
  scale_color_discrete(name = "Parameter name",
                       labels = c("Log redds/spawner (RE)",
                                  "Predicted survival rate")) +
  facet_wrap(~stream, scales = "free") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  xlab("Year") + ylab("Mean estimated value") + theme_minimal()  +
  theme(legend.position = "bottom")
```
